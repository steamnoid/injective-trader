#!/usr/bin/env python3
"""
Individual Market Testing Script
Test BTC and ETH markets separately to validate individual market functionality
"""

import asyncio
import logging
from datetime import datetime, timezone
from typing import List
import sys
import os

# Add src to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from injective_bot.connection.injective_client import InjectiveStreamClient
from injective_bot.connection import WebSocketMessage, MessageType, MessageHandler
from injective_bot.config import WebSocketConfig

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('individual_market_test.log')
    ]
)
logger = logging.getLogger(__name__)

class SingleMarketCollector(MessageHandler):
    """Message collector for individual market testing"""
    
    def __init__(self, market_name: str):
        self.market_name = market_name
        self.messages = []
        self.markets_seen = set()
        self.start_time = None
        self.orderbook_messages = 0
        self.trade_messages = 0
        
    def get_supported_message_types(self) -> List[MessageType]:
        return [MessageType.ORDERBOOK, MessageType.TRADES, MessageType.MARKET_DATA]
    
    async def handle_message(self, message: WebSocketMessage) -> None:
        if self.start_time is None:
            self.start_time = datetime.now(timezone.utc)
            
        self.messages.append(message)
        
        if message.market_id:
            self.markets_seen.add(message.market_id)
            
        # Count message types
        if message.message_type == MessageType.ORDERBOOK:
            self.orderbook_messages += 1
        elif message.message_type == MessageType.TRADES:
            self.trade_messages += 1
            
        logger.info(f"üì® {self.market_name} Message #{len(self.messages)}: {message.message_type.value} for {message.market_id}")

async def test_btc_market():
    """Test BTC market individually"""
    logger.info("\n" + "="*80)
    logger.info("üöÄ TESTING BTC MARKET INDIVIDUALLY")
    logger.info("="*80)
    
    config = WebSocketConfig(connection_timeout=30.0)
    
    # BTC/USDT market ID
    btc_market_id = "0x4ca0f92fc28be0c9761326016b5a1a2177dd6375558365116b5bdda9abc229ce"
    
    client = InjectiveStreamClient(config=config, network="mainnet")
    collector = SingleMarketCollector("BTC")
    client.register_handler(collector)
    
    try:
        # Connect
        logger.info("üîå Connecting to Injective Protocol...")
        connected = await client.connect()
        if not connected:
            logger.error("‚ùå Failed to connect")
            return False
            
        logger.info("‚úÖ Connected successfully")
        
        # Subscribe to BTC market only
        logger.info(f"üìä Subscribing to BTC orderbook updates...")
        await client.subscribe_spot_orderbook_updates([btc_market_id])
        
        logger.info(f"üí± Subscribing to BTC trades updates...")
        await client.subscribe_spot_trades_updates([btc_market_id])
        
        # Wait for data
        logger.info("‚è∞ Waiting 15 seconds for BTC data...")
        await asyncio.sleep(15)
        
        # Results
        message_count = len(collector.messages)
        markets_with_data = len(collector.markets_seen)
        
        logger.info(f"\nüìà BTC MARKET RESULTS:")
        logger.info(f"   üì® Total messages: {message_count}")
        logger.info(f"   üìä Orderbook messages: {collector.orderbook_messages}")
        logger.info(f"   üí± Trade messages: {collector.trade_messages}")
        logger.info(f"   üè™ Markets with data: {markets_with_data}")
        logger.info(f"   üéØ Expected market: {btc_market_id}")
        logger.info(f"   üìã Markets seen: {list(collector.markets_seen)}")
        
        # Validation
        success = message_count > 0 and markets_with_data > 0
        if success:
            logger.info("‚úÖ BTC MARKET TEST: PASSED")
        else:
            logger.error("‚ùå BTC MARKET TEST: FAILED")
            
        return success
        
    except Exception as e:
        logger.error(f"‚ùå BTC test error: {e}")
        return False
        
    finally:
        try:
            await client.disconnect()
            logger.info("üîå Disconnected from BTC test")
        except Exception as e:
            logger.error(f"Disconnect error: {e}")

async def test_eth_market():
    """Test ETH market individually"""
    logger.info("\n" + "="*80)
    logger.info("üöÄ TESTING ETH MARKET INDIVIDUALLY")
    logger.info("="*80)
    
    config = WebSocketConfig(connection_timeout=30.0)
    
    # WETH/USDT market ID
    eth_market_id = "0xd1956e20d74eeb1febe31cd37060781ff1cb266f49e0512b446a5fafa9a16034"
    
    client = InjectiveStreamClient(config=config, network="mainnet")
    collector = SingleMarketCollector("ETH")
    client.register_handler(collector)
    
    try:
        # Connect
        logger.info("üîå Connecting to Injective Protocol...")
        connected = await client.connect()
        if not connected:
            logger.error("‚ùå Failed to connect")
            return False
            
        logger.info("‚úÖ Connected successfully")
        
        # Subscribe to ETH market only
        logger.info(f"üìä Subscribing to ETH orderbook updates...")
        await client.subscribe_spot_orderbook_updates([eth_market_id])
        
        logger.info(f"üí± Subscribing to ETH trades updates...")
        await client.subscribe_spot_trades_updates([eth_market_id])
        
        # Wait for data
        logger.info("‚è∞ Waiting 15 seconds for ETH data...")
        await asyncio.sleep(15)
        
        # Results
        message_count = len(collector.messages)
        markets_with_data = len(collector.markets_seen)
        
        logger.info(f"\nüìà ETH MARKET RESULTS:")
        logger.info(f"   üì® Total messages: {message_count}")
        logger.info(f"   üìä Orderbook messages: {collector.orderbook_messages}")
        logger.info(f"   üí± Trade messages: {collector.trade_messages}")
        logger.info(f"   üè™ Markets with data: {markets_with_data}")
        logger.info(f"   üéØ Expected market: {eth_market_id}")
        logger.info(f"   üìã Markets seen: {list(collector.markets_seen)}")
        
        # Validation
        success = message_count > 0 and markets_with_data > 0
        if success:
            logger.info("‚úÖ ETH MARKET TEST: PASSED")
        else:
            logger.error("‚ùå ETH MARKET TEST: FAILED")
            
        return success
        
    except Exception as e:
        logger.error(f"‚ùå ETH test error: {e}")
        return False
        
    finally:
        try:
            await client.disconnect()
            logger.info("üîå Disconnected from ETH test")
        except Exception as e:
            logger.error(f"Disconnect error: {e}")

async def test_both_markets_combined():
    """Test both markets together after individual validation"""
    logger.info("\n" + "="*80)
    logger.info("üöÄ TESTING BTC + ETH MARKETS COMBINED")
    logger.info("="*80)
    
    config = WebSocketConfig(connection_timeout=30.0)
    
    # Both market IDs
    test_markets = [
        "0x4ca0f92fc28be0c9761326016b5a1a2177dd6375558365116b5bdda9abc229ce",  # BTC/USDT
        "0xd1956e20d74eeb1febe31cd37060781ff1cb266f49e0512b446a5fafa9a16034",  # WETH/USDT
    ]
    
    client = InjectiveStreamClient(config=config, network="mainnet")
    collector = SingleMarketCollector("BTC+ETH")
    client.register_handler(collector)
    
    try:
        # Connect
        logger.info("üîå Connecting to Injective Protocol...")
        connected = await client.connect()
        if not connected:
            logger.error("‚ùå Failed to connect")
            return False
            
        logger.info("‚úÖ Connected successfully")
        
        # Subscribe to both markets
        logger.info(f"üìä Subscribing to orderbook updates for {len(test_markets)} markets...")
        await client.subscribe_spot_orderbook_updates(test_markets)
        
        logger.info(f"üí± Subscribing to trades updates for {len(test_markets)} markets...")
        await client.subscribe_spot_trades_updates(test_markets)
        
        # Wait for data
        logger.info("‚è∞ Waiting 20 seconds for combined data...")
        await asyncio.sleep(20)
        
        # Results
        message_count = len(collector.messages)
        markets_with_data = len(collector.markets_seen)
        
        logger.info(f"\nüìà COMBINED MARKETS RESULTS:")
        logger.info(f"   üì® Total messages: {message_count}")
        logger.info(f"   üìä Orderbook messages: {collector.orderbook_messages}")
        logger.info(f"   üí± Trade messages: {collector.trade_messages}")
        logger.info(f"   üè™ Markets with data: {markets_with_data}")
        logger.info(f"   üéØ Expected markets: {len(test_markets)}")
        logger.info(f"   üìã Markets seen: {list(collector.markets_seen)}")
        
        # Calculate coverage
        coverage_percentage = (markets_with_data / len(test_markets)) * 100
        logger.info(f"   üìä Market coverage: {coverage_percentage:.1f}%")
        
        # Validation
        success = message_count > 0 and markets_with_data == len(test_markets)
        if success:
            logger.info("‚úÖ COMBINED MARKETS TEST: PASSED")
        else:
            logger.error("‚ùå COMBINED MARKETS TEST: FAILED")
            
        return success
        
    except Exception as e:
        logger.error(f"‚ùå Combined test error: {e}")
        return False
        
    finally:
        try:
            await client.disconnect()
            logger.info("üîå Disconnected from combined test")
        except Exception as e:
            logger.error(f"Disconnect error: {e}")

async def main():
    """Run all individual market tests"""
    logger.info("üéØ INDIVIDUAL MARKET TESTING SUITE")
    logger.info(f"üìÖ Started at: {datetime.now(timezone.utc)}")
    
    # Test results
    results = {
        'btc': False,
        'eth': False,
        'combined': False
    }
    
    # Test BTC individually
    logger.info("\nüî∏ Step 1: Testing BTC market individually...")
    results['btc'] = await test_btc_market()
    
    # Wait between tests
    logger.info("\n‚è≥ Waiting 5 seconds before next test...")
    await asyncio.sleep(5)
    
    # Test ETH individually
    logger.info("\nüî∏ Step 2: Testing ETH market individually...")
    results['eth'] = await test_eth_market()
    
    # Wait between tests
    logger.info("\n‚è≥ Waiting 5 seconds before combined test...")
    await asyncio.sleep(5)
    
    # Test both combined only if individual tests pass
    if results['btc'] and results['eth']:
        logger.info("\nüî∏ Step 3: Testing combined markets...")
        results['combined'] = await test_both_markets_combined()
    else:
        logger.warning("\n‚ö†Ô∏è Skipping combined test due to individual test failures")
    
    # Final summary
    logger.info("\n" + "="*80)
    logger.info("üìã FINAL TEST SUMMARY")
    logger.info("="*80)
    logger.info(f"ü™ô BTC Market Test: {'‚úÖ PASSED' if results['btc'] else '‚ùå FAILED'}")
    logger.info(f"üíé ETH Market Test: {'‚úÖ PASSED' if results['eth'] else '‚ùå FAILED'}")
    logger.info(f"üîó Combined Test: {'‚úÖ PASSED' if results['combined'] else '‚ùå FAILED (or skipped)'}")
    
    all_passed = all(results.values())
    logger.info(f"\nüéØ OVERALL RESULT: {'‚úÖ ALL TESTS PASSED' if all_passed else '‚ùå SOME TESTS FAILED'}")
    
    if all_passed:
        logger.info("üöÄ Layer 2 multiple market subscription issue is RESOLVED!")
    else:
        logger.error("üîß Further investigation needed for failing markets")
    
    return all_passed

if __name__ == "__main__":
    try:
        result = asyncio.run(main())
        exit_code = 0 if result else 1
        print(f"\nExiting with code: {exit_code}")
        exit(exit_code)
    except KeyboardInterrupt:
        logger.info("\nüõë Test interrupted by user")
        exit(1)
    except Exception as e:
        logger.error(f"‚ùå Test suite error: {e}")
        exit(1)
